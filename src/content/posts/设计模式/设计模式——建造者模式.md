---
title: "设计模式——建造者模式"
description: "建造者模式是一种对象构建模式，它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同表现的对象。本文详细介绍了建造者模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/builder.webp"
categories: ["设计模式", "创建型模式"]
tags: ["建造者模式", "C++", "设计模式", "创建型模式", "对象构建"]
---

# 设计模式——建造者模式

## 一、基本概念

### 1. 定义

> **建造者模式**（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。

### 2. 优缺点

**优点**：

- 封装性好，构建和表示分离。
- 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
- 屏蔽细节，客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

**缺点**：

- 产品的组成部分必须相同，这限制了其使用范围。
- 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。

### 3. 结构

建造者（Builder）模式的主要角色如下：

- **产品角色（Product）**：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
- **抽象建造者（Builder）**：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 `getResult()`。
- **具体建造者(Concrete Builder）**：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
- **指挥者（Director）**：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

![建造者模式的结构图](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/3-1Q1141H441X4.gif)

## 二、代码实现

### 产品角色

产品角色包含多个组成部件的复杂对象：

```cpp
#include <iostream>
#include <string>

class Product {
private:
    std::string partA;
    std::string partB;
    std::string partC;

public:
    void setPartA(const std::string& partA) {
        this->partA = partA;
    }

    void setPartB(const std::string& partB) {
        this->partB = partB;
    }

    void setPartC(const std::string& partC) {
        this->partC = partC;
    }

    void show() {
        std::cout << "Product{"
                  << "partA='" << partA << '\''
                  << ", partB='" << partB << '\''
                  << ", partC='" << partC << '\''
                  << '}' << std::endl;
    }
};
```

### 抽象建造者

抽象建造者包含创建产品各个子部件的抽象方法：

```cpp
// 前向声明
class Product;

class Builder {
protected:
    std::unique_ptr<Product> product;

public:
    Builder() : product(std::make_unique<Product>()) {}
    virtual ~Builder() = default;

    // 创建各个子部分
    virtual void buildPartA() = 0;
    virtual void buildPartB() = 0;
    virtual void buildPartC() = 0;

    std::unique_ptr<Product> getProduct() {
        // 返回产品对象
        return std::move(product);
    }
};
```

### 具体建造者

具体建造者实现了抽象建造者接口：

```cpp
#include <iostream>
#include <memory>

class ConcreteBuilder : public Builder {
public:
    void buildPartA() override {
        std::cout << "建造 PartA..." << std::endl;
        product->setPartA("PartA");
    }

    void buildPartB() override {
        std::cout << "建造 PartB..." << std::endl;
        product->setPartB("PartB");
    }

    void buildPartC() override {
        std::cout << "建造 PartC..." << std::endl;
        product->setPartC("PartC");
    }
};
```

### 指挥者

指挥者会调用建造者中的方法完成复杂对象的创建：

```cpp
#include <iostream>
#include <memory>

// 前向声明
class Builder;

class Director {
private:
    std::shared_ptr<Builder> builder;

public:
    Director(std::shared_ptr<Builder> builder) : builder(builder) {}

    std::unique_ptr<Product> construct() {
        std::cout << "开始制造产品..." << std::endl;
        builder->buildPartA();
        builder->buildPartB();
        builder->buildPartC();
        std::cout << "产品制造完成！" << std::endl;
        return builder->getProduct();
    }
};
```

### 客户类

```cpp
#include <iostream>
#include <memory>

int main() {
    auto builder = std::make_shared<ConcreteBuilder>();
    Director director(builder);
    auto product = director.construct();
    product->show();
    
    return 0;
}
```

运行结果：

```
开始制造产品...
建造 PartA...
建造 PartB...
建造 PartC...
产品制造完成！
Product{partA='PartA', partB='PartB', partC='PartC'}
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)