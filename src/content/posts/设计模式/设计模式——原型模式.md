---
title: "设计模式——原型模式"
description: "原型模式是创建型模式的一种，其特点在于通过复制一个已经存在的实例来返回新的实例，而不是新建实例。本文详细介绍了原型模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/prototype.webp"
categories: ["设计模式", "创建型模式"]
tags: ["原型模式", "C++", "设计模式", "创建型模式", "克隆"]
---

# 设计模式——原型模式

## 一、基本概念

### 1. 定义

> **原型模式**是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。
>
> 原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。

### 2. 优缺点

**优点**：

- Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良；
- 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

**缺点**：

- 需要为每一个类都配置一个 clone 方法；
- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则；
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

### 3. 结构

原型模式包含以下主要角色。

- **抽象原型类**：规定了具体原型对象必须实现的接口；
- **具体原型类**：实现抽象原型类的 clone() 方法，它是可被复制的对象；
- **访问类**：使用具体原型类中的 clone() 方法来复制新的对象。

### 4. UML

Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。

![原型模式的结构图](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/3-1Q114101Fa22.gif)

## 二、代码实现

原型模式的克隆分为浅克隆和深克隆。

- **浅克隆**：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址；
- **深克隆**：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

### 浅克隆

在C++中，我们可以通过定义拷贝构造函数或重载赋值运算符来实现浅克隆。

```cpp
#include <iostream>
#include <vector>
#include <memory>

// 抽象原型类
class Prototype {
public:
    virtual ~Prototype() = default;
    virtual std::unique_ptr<Prototype> clone() const = 0;
};

// 具体原型类
class ConcretePrototype : public Prototype {
private:
    int data;
    std::string name;

public:
    ConcretePrototype(int d = 0, const std::string& n = "") : data(d), name(n) {}
    
    // 拷贝构造函数，实现浅克隆
    ConcretePrototype(const ConcretePrototype& other) : data(other.data), name(other.name) {}

    // 克隆方法
    std::unique_ptr<Prototype> clone() const override {
        return std::make_unique<ConcretePrototype>(*this);  // 调用拷贝构造函数
    }

    void setData(int d) { data = d; }
    void setName(const std::string& n) { name = n; }
    
    int getData() const { return data; }
    std::string getName() const { return name; }

    void printInfo() const {
        std::cout << "ConcretePrototype: data=" << data << ", name=" << name << std::endl;
    }
};

// 浅克隆示例
int main() {
    auto prototype = std::make_unique<ConcretePrototype>(100, "original");
    std::vector<std::unique_ptr<Prototype>> prototypes;

    for (int i = 0; i < 5; i++) {
        prototypes.push_back(prototype->clone());  // 浅克隆
    }

    for (const auto& p : prototypes) {
        auto concrete = dynamic_cast<ConcretePrototype*>(p.get());
        if (concrete) {
            concrete->printInfo();
        }
    }

    return 0;
}
```

### 深克隆

在C++中，深克隆通常通过定义自定义的拷贝构造函数和赋值运算符来实现，确保对象中的指针成员也指向独立的内存空间。

```cpp
#include <iostream>
#include <memory>
#include <string>

// 目标类 - 需要被深拷贝的对象
class Target {
public:
    std::string name;
    
    Target(const std::string& n) : name(n) {}
    
    // 拷贝构造函数，实现深拷贝
    Target(const Target& other) : name(other.name) {}
    
    // 赋值运算符
    Target& operator=(const Target& other) {
        if (this != &other) {
            name = other.name;
        }
        return *this;
    }
    
    void printInfo() const {
        std::cout << "Target: name=" << name << std::endl;
    }
    
    bool equals(const Target& other) const {
        return name == other.name;
    }
};

// 具体原型类 - 包含目标对象的引用
class ConPrototype {
private:
    std::unique_ptr<Target> target;

public:
    ConPrototype() : target(std::make_unique<Target>("小红")) {}
    
    ConPrototype(const std::string& targetName) : target(std::make_unique<Target>(targetName)) {}
    
    // 深克隆方法 - 重要：需要深拷贝所有指针成员
    std::unique_ptr<ConPrototype> deepClone() const {
        // 创建新对象并深拷贝所有成员
        auto new_obj = std::make_unique<ConPrototype>();
        new_obj->target = std::make_unique<Target>(*this->target);  // 深拷贝target对象
        return new_obj;
    }
    
    // 拷贝构造函数实现深拷贝
    ConPrototype(const ConPrototype& other) {
        if (other.target) {
            this->target = std::make_unique<Target>(*other.target);  // 深拷贝target
        }
    }
    
    // 赋值运算符实现深拷贝
    ConPrototype& operator=(const ConPrototype& other) {
        if (this != &other) {
            if (other.target) {
                this->target = std::make_unique<Target>(*other.target);  // 深拷贝
            } else {
                this->target.reset();  // 如果原对象没有target，则清空当前对象的target
            }
        }
        return *this;
    }
    
    Target* getTarget() {
        return target.get();
    }
    
    const Target* getTarget() const {
        return target.get();
    }
    
    void printInfo() const {
        if (target) {
            target->printInfo();
        }
    }
};

// 深克隆示例
int main() {
    auto obj = std::make_unique<ConPrototype>();
    auto obj1 = obj->deepClone();  // 深克隆
    
    // 比较两个对象的target是否相同（应该不同，但内容相同）
    if (obj->getTarget() && obj1->getTarget()) {
        std::cout << "obj target address: " << obj->getTarget() << std::endl;
        std::cout << "obj1 target address: " << obj1->getTarget() << std::endl;
        std::cout << "Are targets equal (content): " << 
                     (obj->getTarget()->equals(*obj1->getTarget()) ? "true" : "false") << std::endl;
        std::cout << "Are targets same object: " << 
                     (obj->getTarget() == obj1->getTarget() ? "true" : "false") << std::endl;
    }
    
    return 0;
}
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)