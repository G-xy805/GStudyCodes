---
title: "设计模式——装饰器模式"
description: "装饰器模式是一种动态地往一个类中添加新的行为的设计模式。它允许向一个现有的对象添加新的功能，同时又不改变其结构。本文详细介绍了装饰器模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/decorator.webp"
categories: ["设计模式", "结构型模式"]
tags: ["装饰器模式", "C++", "设计模式", "结构型模式", "动态添加功能"]
---

# 设计模式——装饰器模式

## 一、基本概念

### 1. 定义

> **修饰模式**，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。

### 2. 优缺点

**优点**：

- 是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用；
- 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；
- 装饰器模式完全遵守开闭原则。

**缺点**：

- 装饰器模式会增加许多子类，过度使用会增加程序得复杂性。

### 3. 结构

- **抽象构件（Component）角色**：定义一个抽象接口以规范准备接收附加责任的对象；
- **具体构件（ConcreteComponent）角色**：实现抽象构件，通过装饰角色为其添加一些职责；
- **抽象装饰（Decorator）角色**：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能；
- **具体装饰（ConcreteDecorator）角色**：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

![image-20210301214602501](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/image-20210301214602501.png)

## 二、代码实现

### 抽象构件角色

```cpp
class Component {
public:
    virtual ~Component() = default;
    virtual void operation() = 0;
};
```

### 具体构件角色

```cpp
#include <iostream>

class ConcreteComponent : public Component {
public:
    ConcreteComponent() {
        std::cout << "创建具体的构建角色..." << std::endl;
    }

    void operation() override {
        std::cout << "原有功能！" << std::endl;
    }
};
```

### 抽象装饰角色

```cpp
#include <memory>

class Decorator : public Component {
protected:
    std::shared_ptr<Component> component;

public:
    Decorator(std::shared_ptr<Component> component) : component(component) {}

    void operation() override {
        if (component) {
            component->operation();
        }
    }
};
```

### 具体装饰角色

```cpp
#include <iostream>

class ConcreteDecorator : public Decorator {
public:
    ConcreteDecorator(std::shared_ptr<Component> component) : Decorator(component) {}

    void operation() override {
        Decorator::operation();
        addFunction();
    }

    void addFunction() {
        std::cout << "额外功能！" << std::endl;
    }
};
```

### 客户类

```cpp
#include <iostream>
#include <memory>

int main() {
    auto component = std::make_shared<ConcreteComponent>();
    component->operation();
    std::cout << "--------------" << std::endl;
    auto component1 = std::make_shared<ConcreteDecorator>(component);
    component1->operation();
    
    return 0;
}
```

运行结果：

```
创建具体的构建角色...
原有功能！
--------------
原有功能！
额外功能！
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)

