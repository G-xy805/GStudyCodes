---
title: 策略模式实现详解
description: 详细介绍策略模式的概念、优缺点及实际应用场景，特别是支付系统的策略实现
pubDate: 2025-12-06
image: "/image/strategy-pattern.jpg"
categories:
  - 设计模式
tags:
  - 策略模式
  - C++
  - 支付系统
---

# 02.策略模式实现

策略模式的优缺点：

优点：

1. 避免多重的条件判断

2. 易扩展

缺点：

1. 代码量增多

2. 策略实现需要对外暴露

可以先看看如果没有使用策略模式，那我们在遇到扩展时是怎么处理的。就拿支付来举例吧。伪代码如下：

```cpp
std::string doPay(const PayParam& payParam) {
    // 先验
    preCheck(payParam);
    std::string result;
    if(payParam.getPayChannelEnum() == PayChannelEnum::ALI) {
        // 支付宝支付的一些校验和处理
        result = doAli(payParam);
    } else if (payParam.getPayChannelEnum() == PayChannelEnum::WECHAT) {
        // 微信支付的一些校验和处理
        result = doWechat(payParam);
    } else {
        // 其他情况的处理
        result.clear();
    }
    // 结果处理
    result = resultHandle(result);
    return result;
}
```
这个时候如果又加上了银联支付，那么就得在这个if else的分支上进行修改，再加一个分支，如果我们的处理不只是这么简单的话，甚至还涉及到代码结构的调整，先验和结果处理调整，这不符合代码封装的开闭原则。而且也会改得很令人头痛。

## 1.策略实现

使用策略模式实现也是有好几种方法的，下面我就来讲讲我在真实场景中使用过的策略实现吧。

## 2.第一种

这种方式非常简单，简直就是上面的if else套了个封装的壳子而已。定义一个接口，然后接口有几个实现，在根据if else判断需要构造哪个实现。然后调用执行方法。

```cpp
#include <memory>
#include <string>

// 策略接口类，用于抽象支付的行为
class PayStrategy {
public:
    virtual ~PayStrategy() = default;
    virtual std::string doPay(const PayParam& payParam) = 0;
};

// 具体支付宝支付的实现
class AliPayStrategyImpl : public PayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "alipay";
    }
};

// 具体微信支付的实现
class WechatPayStrategyImpl : public PayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "wechatpay";
    }
};

// 调用支付的入口
class OrderPay {
private:
    void preCheck(const PayParam& payParam) {
    
    }
    
    std::string resultHandle(const std::string& result) {
        // do something
        return "result";
    }

public:
    std::string doPay(const PayParam& payParam) {
        // 先验
        preCheck(payParam);
        std::unique_ptr<PayStrategy> payStrategy = nullptr;
        if(payParam.getPayChannelEnum() == PayChannelEnum::ALI) {
            payStrategy = std::make_unique<AliPayStrategyImpl>();
        } else if (payParam.getPayChannelEnum() == PayChannelEnum::WECHAT) {
            payStrategy = std::make_unique<WechatPayStrategyImpl>();
        }
        std::string result = payStrategy ? payStrategy->doPay(payParam) : "";
        // 结果处理
        result = resultHandle(result);
        return result;
    }
};
```

这种如果需要扩展的话，就是再加一个实现类，然后if else这里构造实现类的地方再增加一个分支，其实也没有完全解决掉对修改关闭的问题。当然如果将bean交给spring管理的话又会方便很多。

## 3.第二种（推荐）

这种就比较有趣了，是使用枚举类来进行多策略的实现。下面我们就一起来看看吧。

```cpp
#include <functional>
#include <unordered_map>
#include <string>

enum class PayChannelEnum {
    ALI,
    WECHAT
};

class PayStrategy {
public:
    virtual ~PayStrategy() = default;
    virtual std::string doPay(const PayParam& payParam) = 0;
};

class PayStrategyFactory {
private:
    static std::unordered_map<PayChannelEnum, std::function<std::string(const PayParam&)>> strategies;
    
public:
    static void init() {
        strategies[PayChannelEnum::ALI] = [](const PayParam& payParam) -> std::string {
            return "alipay";
        };
        strategies[PayChannelEnum::WECHAT] = [](const PayParam& payParam) -> std::string {
            return "wechatpay";
        };
    }
    
    static std::string executePay(PayChannelEnum channel, const PayParam& payParam) {
        auto it = strategies.find(channel);
        if (it != strategies.end()) {
            return it->second(payParam);
        }
        return "";
    }
};

// 初始化静态成员
std::unordered_map<PayChannelEnum, std::function<std::string(const PayParam&)>> PayStrategyFactory::strategies;
```

这种方式，代码看着很简洁，逻辑也很清晰，使用也很方便；但是有一个缺点，如果你需要用到spring注入的对象的话，这种方式就无法工作了。

## 4.第三种

接下来这种就需要依赖于Spring的IOC和DI了，这两者是啥我这里就不展开介绍了，如果不了解的小伙伴，可以去搜索一下，大致的就是帮我们管理实现类的，类构造和注入等。

```cpp
#include <memory>
#include <unordered_map>
#include <string>

// 策略接口类，用于抽象支付的行为。依然需要一个策略接口用来抽象支付的行为
class PayStrategy {
public:
    virtual ~PayStrategy() = default;
    virtual std::string doPay(const PayParam& payParam) = 0;
};

// 具体支付宝支付的实现
class AliPayStrategyImpl : public PayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "alipay";
    }
};

// 具体微信支付的实现
class WechatPayStrategyImpl : public PayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "wechatpay";
    }
};

// 策略工厂类，模拟依赖注入
class StrategyFactory {
private:
    std::unordered_map<std::string, std::unique_ptr<PayStrategy>> payStrategyMap;
    
public:
    StrategyFactory() {
        // 注册策略实现
        payStrategyMap["ALI"] = std::make_unique<AliPayStrategyImpl>();
        payStrategyMap["WECHAT"] = std::make_unique<WechatPayStrategyImpl>();
    }
    
    PayStrategy* getPayStrategy(const std::string& key) {
        auto it = payStrategyMap.find(key);
        return it != payStrategyMap.end() ? it->second.get() : nullptr;
    }
};

// 调用支付的入口
class OrderPay {
private:
    StrategyFactory strategyFactory;
    
    void preCheck(const PayParam& payParam) {
        // do something check
    }
    
    std::string resultHandle(const std::string& result) {
        // do something
        return "result";
    }

public:
    std::string doPay(const PayParam& payParam) {
        preCheck(payParam);
        PayStrategy* strategy = strategyFactory.getPayStrategy(payParam.getPayChannelEnumName());
        std::string result = strategy ? strategy->doPay(payParam) : "";
        return resultHandle(result);
    }
};
```

当然这里我们是没有考虑那些异常情况，以及策略未找到之类的兜底或者处理等。实际编程是需要都考虑的。

可以看到在这段实现中我是标了几个重点。

1. 首先是各自的实现类需要指定bean名称（策略指定的枚举名称），这是为了在依赖注入的时候方便我们匹配用的

2. 其次是在调用的入口OrderPay一定也需要加上Spring的bean声明注解，这是为了将bean统一交给Spring管理，才能将策略实现注入
3. payStrategyMap这个域对应的是个map，key为实例名，value为对应的实例。这样在调用doPay时就可以根据传入的策略枚举找到实例然后执行具体方法。

缺点也很明显，需要指定实例名称，且需要是一个静态常量，所以也不能直接使用枚举的名称。这样容易出现两个问题。

1. 实例名称如果和其他实例冲突会导致启动服务就报错，那换个实例名称的话，枚举也得跟着改动，容易引起其他依赖的问题。
2. 枚举的name和实例名称需要一一对应，如果有哪里大小写或者字符敲错了等问题，不太容易排查。

## 5.第四种（推荐）

这种目前是我常用的一种策略实现，不过呢，如果策略本身比较少的话，写这个轮子可能会觉得比较浪费，因为本身的架子代码就挺多的了。话不多说，show you the code。

```cpp
#include <memory>
#include <unordered_map>
#include <vector>
#include <functional>

// 很熟悉了吧？一定需要的一个策略接口
class PayStrategy {
public:
    virtual ~PayStrategy() = default;
    virtual std::string doPay(const PayParam& payParam) = 0;
};

// 重要。实现策略的一个抽象类。用于定义所有的策略实现的基类
class AbstractPayStrategy : public PayStrategy {
public:
    // 重要。新定义一个策略实现类需要实现的策略。返回对应的枚举
    virtual PayChannelEnum strategy() const = 0;
};

// 基础实现，注意，此处是实现顶上的策略接口。在调用入口地方也是注入此实现。
class PayStrategyImpl : public PayStrategy {
private:
    std::unordered_map<PayChannelEnum, std::shared_ptr<AbstractPayStrategy>> payStrategies;
    
public:
    // 构造器注入。然后转化成map存储。
    PayStrategyImpl(const std::vector<std::shared_ptr<AbstractPayStrategy>>& payStrategyList) {
        for (const auto& strategy : payStrategyList) {
            payStrategies[strategy->strategy()] = strategy;
        }
    }
    
    // 实际的支付接口都是调用此方法
    std::string doPay(const PayParam& payParam) override {
        auto it = payStrategies.find(payParam.getPayChannelEnum());
        if (it != payStrategies.end()) {
            return it->second->doPay(payParam);
        }
        return "";
    }
};

// 注意这里的改动，此处是继承抽象类，并且实现返回策略枚举的接口
class AliPayStrategyImpl : public AbstractPayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "alipay";
    }
    
    PayChannelEnum strategy() const override {
        return PayChannelEnum::ALI;
    }
};

class WechatPayStrategyImpl : public AbstractPayStrategy {
public:
    std::string doPay(const PayParam& payParam) override {
        return "wechatpay";
    }
    
    PayChannelEnum strategy() const override {
        return PayChannelEnum::WECHAT;
    }
};
```

到此整体的架子就已经搭建好了，而具体的调用入口也是很简单的一个注入即可。

@Autowired
private OrderPay orderPay;
这种实现代码量很多，但是基本上模糊了选择策略的那部分逻辑，而且有个很重要的优点是只需要维护一个策略枚举，能很方便的将实现与策略枚举映射起来。

其中用到的知识点有：

构造器注入。PayStrategyImpl有定义一个List参数的构造方法，实例化该类时会自动将Spring管理的策略bean注入进去
Spring的Primary注入，当接口有多个实现时，使用Autowired注解的话，Spring并不知道选择哪个bean注入，所以如果加上Primary时就可以给Spring决策，优先注入那个实例。
类图如下：

![img](https://img-blog.csdnimg.cn/img_convert/d412e57526525ce2168ea1d589a4f522.jpeg)

## 6.最后

关于策略模式的多种实现，到这里就算结束了。也是有写几个我平常有使用的策略模式实现，当然还有一些其实可以改造一下形成自己代码风格的实现方式，比如第三种，可以再定义一个Map，在bean实例化时将自身put到Map中（可以通过@PostConstruct注解的方式，或者实现InitializingBean的方式等），然后剩下的工作就水到渠成了。

每种实现其实都是有一些优缺点的，也并不一定适用于所有人和所有场景，希望大家能够找到符合自己代码风格的实现思路，也希望大家能够通过这一节对策略模式有一个清晰一点的认识，在实际工作中能够更简洁清晰的写自己的bug咯～。
