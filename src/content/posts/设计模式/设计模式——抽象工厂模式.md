---
title: "设计模式——抽象工厂模式"
description: "抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。本文详细介绍了抽象工厂模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/abstract-factory.webp"
categories: ["设计模式", "创建型模式"]
tags: ["抽象工厂模式", "C++", "设计模式", "创建型模式", "工厂模式"]
---

# 设计模式——抽象工厂模式

## 一、基本概念

### 1. 定义

> **抽象工厂模式**（英语：**Abstract factory pattern**）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。
>
> 在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。

### 2. 优缺点

**优点**：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
- 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
- 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。
- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

**缺点**：

- 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

### 3. 结构

抽象工厂模式的主要角色如下。

- **抽象工厂（Abstract Factory）**：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品；
- **具体工厂（Concrete Factory）**：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
- **抽象产品（Product）**：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
- **具体产品（ConcreteProduct）**：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

![抽象工厂模式的 UML 图](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

## 二、代码实现

`AbstractFactory.h`:

```cpp
#include <string>
#include <memory>

// 前向声明
class Color;
class Shape;

/*
 * 抽象工厂
 * */
class AbstractFactory {
public:
    virtual ~AbstractFactory() = default;
    virtual std::unique_ptr<Color> getColor(const std::string& color) = 0;
    virtual std::unique_ptr<Shape> getShape(const std::string& shape) = 0;
};
```

`ShapeFactory.h`：

```cpp
#include <iostream>
#include <string>
#include <memory>

/*
 * 形状工厂
 * */
class Shape {
public:
    virtual ~Shape() = default;
    virtual void creatShape() = 0;
};

class Rectangle : public Shape {
public:
    void creatShape() override {
        std::cout << "创建一个矩形..." << std::endl;
    }
};

class Circle : public Shape {
public:
    void creatShape() override {
        std::cout << "创建一个圆形..." << std::endl;
    }
};

class Square : public Shape {
public:
    void creatShape() override {
        std::cout << "创建一个正方形..." << std::endl;
    }
};

/*
 * 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象
 * */
class ShapeFactory : public AbstractFactory {
public:
    std::unique_ptr<Color> getColor(const std::string& color) override {
        return nullptr;
    }

    std::unique_ptr<Shape> getShape(const std::string& shape) override {
        if (shape == "circle") {
            return std::make_unique<Circle>();
        } else if (shape == "rectangle") {
            return std::make_unique<Rectangle>();
        } else if (shape == "square") {
            return std::make_unique<Square>();
        } else {
            return nullptr;
        }
    }
};
```

`ColorFactory.h`:

```cpp
#include <iostream>
#include <string>
#include <memory>

/*
 * 颜色工厂
 * */
class Color {
public:
    virtual ~Color() = default;
    virtual void fillColor() = 0;
};

class Red : public Color {
public:
    void fillColor() override {
        std::cout << "喷涂红色..." << std::endl;
    }
};

class Green : public Color {
public:
    void fillColor() override {
        std::cout << "喷涂绿色..." << std::endl;
    }
};

class Blue : public Color {
public:
    void fillColor() override {
        std::cout << "喷涂蓝色..." << std::endl;
    }
};

class ColorFactory : public AbstractFactory {
public:
    std::unique_ptr<Color> getColor(const std::string& color) override {
        if (color == "red") {
            return std::make_unique<Red>();
        } else if (color == "green") {
            return std::make_unique<Green>();
        } else if (color == "blue") {
            return std::make_unique<Blue>();
        } else {
            return nullptr;
        }
    }

    std::unique_ptr<Shape> getShape(const std::string& shape) override {
        return nullptr;
    }
};
```

`FactoryProducer.h`:

```cpp
#include <string>
#include <memory>

/*
* 创建一个工厂生成器类，通过传递形状或颜色信息来获取工厂
* */
class FactoryProducer {
public:
    static std::unique_ptr<AbstractFactory> getFactory(const std::string& choice) {
        if (choice == "color") {
            return std::make_unique<ColorFactory>();
        } else if (choice == "shape") {
            return std::make_unique<ShapeFactory>();
        } else {
            return nullptr;
        }
    }
};
```

`main.cpp`:

```cpp
#include <iostream>
#include <memory>

int main() {
    auto sf = FactoryProducer::getFactory("shape");
    if (sf) {
        auto shape = sf->getShape("circle");
        if (shape) {
            shape->creatShape();
        }
    }
    
    return 0;
}
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)

