---
title: "设计模式——桥接模式"
description: "桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。本文详细介绍了桥接模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/bridge.webp"
categories: ["设计模式", "结构型模式"]
tags: ["桥接模式", "C++", "设计模式", "结构型模式", "解耦"]
---

# 设计模式——桥接模式

## 一、基本概念

### 1. 定义

> **桥接模式（Bridge）**是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。

### 2. 优缺点

**优点**：

- 抽象与实现分离，扩展能力强；
- 符合开闭原则；
- 符合合成复用原则；
- 其实现细节对客户透明。

**缺点**：

- 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。

### 3. 结构

桥接（Bridge）模式包含以下主要角色：

- **抽象化（Abstraction）角色**：定义抽象类，并包含一个对实现化对象的引用。
- **扩展抽象化（Refined Abstraction）角色**：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
- **实现化（Implementor）角色**：定义实现化角色的接口，供扩展抽象化角色调用。
- **具体实现化（Concrete Implementor）角色**：给出实现化角色接口的具体实现。

![桥接模式的结构图](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/3-1Q115125253H1.gif)

## 二、代码实现

### UML

![bridge](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/bridge.png)

### 实现角色

颜色接口：

```cpp
#include <string>
#include <iostream>

class Color {
public:
    virtual ~Color() = default;
    virtual void fillColor(const std::string& shape) = 0;
};
```

### 具体实现化角色

红色：

```cpp
class Red : public Color {
public:
    void fillColor(const std::string& shape) override {
        std::cout << "绘制红色的" << shape << std::endl;
    }
};
```

绿色：

```cpp
class Green : public Color {
public:
    void fillColor(const std::string& shape) override {
        std::cout << "绘制绿色的" << shape << std::endl;
    }
};
```

### 抽象化角色

形状类，提供一个画形状的接口，并包含一个颜色的实例：

```cpp
#include <memory>

// 前向声明
class Color;

class Shape {
protected:
    std::shared_ptr<Color> color;

public:
    Shape(std::shared_ptr<Color> color) : color(color) {}
    virtual ~Shape() = default;
    virtual void drawShape() = 0;
};
```

### 拓展抽象化角色

圆形：

```cpp
class Circle : public Shape {
public:
    Circle(std::shared_ptr<Color> color) : Shape(color) {}

    void drawShape() override {
        color->fillColor("圆形");
    }
};
```

正方形：

```cpp
class Square : public Shape {
public:
    Square(std::shared_ptr<Color> color) : Shape(color) {}

    void drawShape() override {
        color->fillColor("正方形");
    }
};
```

### 客户类

```cpp
#include <iostream>
#include <memory>

int main() {
    auto green = std::make_shared<Green>();
    auto circle = std::make_unique<Circle>(green);
    circle->drawShape();

    auto red = std::make_shared<Red>();
    auto square = std::make_unique<Square>(red);
    square->drawShape();
    
    return 0;
}
```

运行结果：

```
绘制绿色的圆形
绘制红色的正方形
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)