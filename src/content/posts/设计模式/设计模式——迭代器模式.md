---
title: "设计模式——迭代器模式"
description: "迭代器模式是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。本文详细介绍了迭代器模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/iterator.webp"
categories: ["设计模式", "行为型模式"]
tags: ["迭代器模式", "C++", "设计模式", "行为型模式", "遍历"]
---

# 设计模式——迭代器模式

## 一、基本概念

### 1. 定义

> **迭代器模式（Iterator）**：是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。

### 2. 优缺点

**优点**：

- 访问一个聚合对象的内容而无须暴露它的内部表示；
- 遍历任务交由迭代器完成，这简化了聚合类；
- 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历；
- 增加新的聚合类和迭代器类都很方便，无须修改原有代码；
- 封装性良好，为遍历不同的聚合结构提供一个统一的接口。

**缺点**：

- 增加了类的个数，这在一定程度上增加了系统的复杂性。

### 3. 结构

- **抽象聚合（Aggregate）角色**：定义存储、添加、删除聚合对象以及创建迭代器对象的接口；
- **具体聚合（ConcreteAggregate）角色**：实现抽象聚合类，返回一个具体迭代器的实例；
- **抽象迭代器（Iterator）角色**：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法；
- **具体迭代器（Concretelterator）角色**：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

![image-20210303212827043](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/image-20210303212827043.png)

## 二、代码实现

### 抽象迭代器

定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法：

```cpp
#include <memory>
#include <string>

template<typename T>
class Iterator {
public:
    virtual ~Iterator() = default;
    virtual T first() = 0;
    virtual T next() = 0;
    virtual bool hasNext() = 0;
};
```

### 具体迭代器

实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置：

```cpp
#include <vector>

template<typename T>
class ConcreteIterator : public Iterator<T> {
private:
    std::vector<T>* list;
    int index;

public:
    ConcreteIterator(std::vector<T>* list) : list(list), index(-1) {}

    T first() override {
        index = 0;
        return list->at(index);
    }

    T next() override {
        T obj{};
        if (hasNext()) {
            obj = list->at(++index);
        }
        return obj;
    }

    bool hasNext() override {
        return index < static_cast<int>(list->size()) - 1;
    }
};
```

### 抽象聚合

定义存储、添加、删除聚合对象以及创建迭代器对象的接口：

```cpp
#include <memory>

template<typename T>
class Aggregate {
public:
    virtual ~Aggregate() = default;
    virtual void add(const T& obj) = 0;
    virtual void remove(const T& obj) = 0;
    virtual std::shared_ptr<Iterator<T>> getIterator() = 0;
};
```

### 具体聚合

实现抽象聚合类，返回一个具体迭代器的实例：

```cpp
#include <vector>
#include <memory>

template<typename T>
class ConcreteAggregate : public Aggregate<T> {
private:
    std::vector<T> list;

public:
    void add(const T& obj) override {
        list.push_back(obj);
    }

    void remove(const T& obj) override {
        auto it = std::find(list.begin(), list.end(), obj);
        if (it != list.end()) {
            list.erase(it);
        }
    }

    std::shared_ptr<Iterator<T>> getIterator() override {
        return std::make_shared<ConcreteIterator<T>>(&list);
    }
};
```

### 客户类

```cpp
#include <iostream>
#include <memory>
#include <string>

int main() {
    auto aggregate = std::make_shared<ConcreteAggregate<std::string>>();
    aggregate->add("西瓜");
    aggregate->add("橘子");
    aggregate->add("苹果");
    aggregate->add("草莓");

    std::cout << "遍历集合：" << std::endl;
    auto iterator = aggregate->getIterator();
    while (iterator->hasNext()) {
        std::string obj = iterator->next();
        std::cout << obj << "\t";
    }
    std::string obj = iterator->first();
    std::cout << std::endl << "First: " << obj << std::endl;
    
    return 0;
}
```

运行结果：

```
遍历集合：
西瓜	橘子	苹果	草莓	
First: 西瓜
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - [Refactoring.Guru](https://refactoringguru.cn/)

