---
title: "设计模式——工厂方法模式"
description: "工厂方法模式是一种实现了工厂概念的面向对象设计模式，它定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。本文详细介绍了工厂方法模式的基本概念、优缺点、结构以及C++实现方式。"
pubDate: "2024-03-15"
image: "/assets/img/design-patterns/factory-method.webp"
categories: ["设计模式", "创建型模式"]
tags: ["工厂方法模式", "C++", "设计模式", "创建型模式", "工厂模式"]
---

# 设计模式——工厂方法模式

## 一、基本概念

### 1. 定义

> **工厂方法模式**（英语：**Factory method pattern**）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”

### 2. 优缺点

**优点：**

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
- 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
- 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

**缺点：**

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

### 3. 结构

工厂方法模式的主要角色如下：

- **抽象工厂（Abstract Factory）**：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品；
- **具体工厂（ConcreteFactory）**：主要是实现抽象工厂中的抽象方法，完成具体产品的创建；
- **抽象产品（Product）**：定义了产品的规范，描述了产品的主要特性和功能；
- **具体产品（ConcreteProduct）**：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应

![工厂方法模式的结构图](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/3-1Q114135A2M3.gif)

## 二、代码实现

```cpp
#include <iostream>
#include <string>
#include <memory>

// 抽象产品
class Shape {
public:
    virtual ~Shape() = default;
    virtual void show() = 0;
};

// 具体产品：矩形
class Rectangle : public Shape {
public:
    void show() override {
        std::cout << "I'm a rectangle." << std::endl;
    }
};

// 具体产品：圆
class Circle : public Shape {
public:
    void show() override {
        std::cout << "I'm a circle." << std::endl;
    }
};

// 抽象工厂
class Factory {
public:
    virtual ~Factory() = default;
    virtual std::unique_ptr<Shape> createShape() = 0;
};

// 生产矩形的工厂
class RectangleFactory : public Factory {
public:
    std::unique_ptr<Shape> createShape() override {
        std::cout << "正在生产矩形..." << std::endl;
        return std::make_unique<Rectangle>();
    }
};

// 生产圆形的工厂
class CircleFactory : public Factory {
public:
    std::unique_ptr<Shape> createShape() override {
        std::cout << "正在生产圆形..." << std::endl;
        return std::make_unique<Circle>();
    }
};

// 客户端代码
int main() {
    std::string productName;
    std::getline(std::cin, productName);
    
    std::unique_ptr<Shape> product;
    std::unique_ptr<Factory> factory;

    if (productName == "Circle") {
        factory = std::make_unique<CircleFactory>();
    } else {
        factory = std::make_unique<RectangleFactory>();
    }
    
    product = factory->createShape();
    product->show();
    
    return 0;
}
```

***

> 参考：
>
> - [菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)
> - [C语言网](http://c.biancheng.net/view/1338.html)
> - https://refactoringguru.cn/